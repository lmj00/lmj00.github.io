---
title: "RabbitMQ"
layout: post
modified_date: 2025-12-25
---

### 개요 
업무 진행 중, 제조 공정 품질 데이터 관리 시스템에서 여러 시스템 간 실시간 알람이 필요했다.
초기에는 Redis Pub/Sub으로 구현했으나, **알람이 유실되면 안 되는 요구사항**이 있었기 때문에, 더 안정적인 메시징 시스템이 필요했다.

물론 Redis AOF(Append Only File)나 RDB(Snapshot) 방식을 사용해서 데이터 영속성을 확보할 수 있었지만, **Redis Pub/Sub은 영속성을 지원하지 않는다**는 근본적인 문제가 있었다.

좀 더 찾아보니 **Redis Stream** 방식으로도 내가 원하는 시스템을 구현 가능하다는 것을 알게 됐지만, 다음과 같은 한계가 있었다:

- Dead Letter Queue 직접 구현
- TTL, Max Length 직접 구현  
- 모니터링 UI 직접 구현
- 복잡도가 높아 유지보수 어려움

이를 대체할 메시지 큐 시스템으론 RabbitMQ와 Kafka를 선택해야 하는 상황이었다.

**Kafka**는 대용량 처리와 이벤트 스트리밍에 최적화되어 있고, 실시간 알림 시스템에도 사용할 수 있지만, 설정/운영이 복잡하고(Zookeeper, Broker, Partition 관리) 
현재 요구사항에는 오버엔지니어링이었다.

**RabbitMQ**는 실시간 메시징에 최적화되어 있고, 설정이 간단하며 필요한 기능(Dead Letter Queue, TTL, Manual ACK 등)을 기본 제공했다.

실시간 알림 시스템에는 RabbitMQ가 더 적합하다고 판단하여 **RabbitMQ**를 최종 선택했다.

---

### RabbitMQ


### Manual ACK
#### ACK(Acknowledgment)란 무엇인가?
- RabbitMQ에서 메시지를 받은 Consumer가 메시지 처리를 완료했다고 알리는 신호
- ACK를 보내면 RabbitMQ는 해당 메시지를 큐에서 삭제

#### AMQP (Advanced Message Queuing Protocol)
- RabbitMQ가 사용하는 메시징 프로토콜
- 메시지 브로커와 클라이언트 간 통신 규약
- ACK는 AMQP 프로토콜의 핵심 메커니즘 중 하나

#### Manual ACK를 선택한 이유
RabbitMQ의 기본 ACK 모드는 Automatic ACK이다.

이 방식은 메시지 수신 즉시 ACK를 RabbitMQ로 보내고, RabbitMQ가 큐에서 메시지를 삭제한다. 

따라서 메시지 처리 중 로직에서 에러가 발생하거나 서버가 예기치 못하게 종료되면, 
이미 메시지가 삭제되어 있어 재처리가 불가능하며, 결과적으로 메시지가 손실된다.

현재 프로젝트는 **알람이 유실되면 안 된다는 조건**이 있었기에 해당 방식은 사용할 수 없었고, **Automatic ACK**가 아닌 **Manual ACK**를 선택했다.

### basicAck와 basicNack
basicAck
- 처리 완료 신호
- RabbitMQ가 메시지를 큐에서 삭제
- channel.basicAck(tag, false) 형태로 사용

basicNack
- 처리 실패 신호
- requeue=true: 메시지를 큐로 다시 돌려보냄
- requeue=false: DLQ로 전송 (재시도하지 않음)
- channel.basicNack(tag, false, false) 형태로 사용

```

```

---

### OutBox Pattern




### 참고
[https://www.rabbitmq.com/confirms.html](https://www.rabbitmq.com/confirms.html)
