---
title: "OOP"
layout: post
category: oop
---


### [추상화(Abstraction)](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81%ED%99%94_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))
> 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 말한다.

> 변수, 함수, 클래스도 모두 추상화이다.

---

### [캡슐화(Encapsulation)](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))
> 캡슐화는 데이터에 대해 동작하는 메커니즘 또는 메서드와 함께 데이터를 하나로 묶는다.

> 캡슐화는 클래스 내부에서 구조화된 데이터 객체의 값 또는 상태를 숨기는 데 사용되며, 숨겨진 구현 세부 사항을 노출하거나 상태 불변성을 위반할 수 있는 방식에 대한 직접 접근을 방지할 수 있다.

> 캡슐화한 변수를 외부에서 접근, 수정하려면 클래스 내부에서 해당 메서드`(getter, setter)`를 만들어줘야 한다.

> 파이썬은 캡슐화를 지원하지 않지만, 파이썬의 규칙인 `언더바(_)`와 `@property`로 캡슐화를 한다.

> 파이썬의 캡슐화는 해당 변수나 메서드를 클래스 밖에서 직접 접근하여 쓰지 말라는 규칙일 뿐, 실제로는 아무런 변화가 없다.

<br>

#### 언더바(_)
```python
class Parent:
    def __init__(self):
        self._count = 0

    def getter(self):
        return self._count

    def setter(self, count):
        self._count = count

p1 = Parent()
print(p1._count) # 0
p1.setter(1)
print(p1._count) # 1
```

<br>

#### [@property](https://docs.python.org/3/library/functions.html#property)
> 데코레이터를 사용하여 getter, setter 메서드를 정의하는 캡슐화다.

```python
class Parent:
    def __init__(self):
        self._count = 0

    @property
    def count(self):
        return self._count

    @count.setter
    def count(self, value):
        self._count = value

p1 = Parent()
print(p1.count)
p1.count = 1
print(p1.count)
```
> `@property`를 통해 동일한 메서드의 이름를 가진 count를 `getter`로 바꾸고, @count.setter를 통해 `setter`의 역할을 하게끔 만든다.


<br>

#### [네임 맹글링(Name Mangling)](https://docs.python.org/3/tutorial/classes.html#private-variables)
> 네임 맹글링 규칙은 주로 [상위 클래스와 하위 클래스의 이름 충돌을 방지](https://peps.python.org/pep-0008/#method-names-and-instance-variables)하기 위해 설계되었습니다. 캡슐화된 변수에 접근하거나 수정하는 것은 여전히 ​​가능합니다.

> 네임 맹글링을 하게 되면 새로운 이름을 갖게 된다.

> 변수나 메서드 이름을 변형시켜, 외부에서 직접적인 접근을 어렵게 만든다. (캡슐화는 아니다)


```python
class Parent:
    def __init__(self):
        self.__update = 0

    def get_update(self):
        return self.__update


class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__update = 1

    def get_update(self):
        return self.__update


parent_obj = Parent()
child_obj = Child()

print(parent_obj.get_update())  # 0
print(child_obj.get_update())   # 1

print(dir(parent_obj)) # '_Parent__update', ...
print(dir(child_obj))  # _Child__update', '_Parent__update', ...

print(parent_obj._Parent__update) # 0
print(child_obj._Child__update)   # 1
print(child_obj._Parent__update)  # 0
```
> `dir`로 확인해 보면 객체가 새로운 이름을 가진 것을 알게 된다.

> 마지막 3줄을 보면 새로운 이름을 가진 객체로 변수에 접근할 수 있기에 캡슐화라고는 할 수 없다.

---



### 상속(Inheritance)


### 다형성(Polymorphism)